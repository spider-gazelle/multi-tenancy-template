require "uuid/json"

class App::Models::Organization < ::PgORM::Base
  table :organizations

  default_primary_key id : UUID, autogenerated: true
  attribute name : String
  attribute description : String?
  attribute subdomain : String?

  attribute owner_id : UUID?
  belongs_to :owner, class_name: User

  attribute admin_group_id : UUID?
  belongs_to :admin_group, class_name: Group

  has_many :domains, class_name: Domain
  has_many :groups, class_name: Group

  include PgORM::Timestamps

  before_save do
    self.name = name.strip
    self.description = description.try(&.strip.presence)
    self.subdomain = subdomain.try(&.strip.downcase.presence)
  end

  validates :subdomain, format: {
    with:    /\A[a-z0-9]([a-z0-9-]*[a-z0-9])?\z/,
    message: "must contain only lowercase letters, numbers, and hyphens",
  }, allow_blank: true

  ensure_unique :subdomain

  def users
    User.join(:inner, OrganizationUser, :user_id).where("organization_users.organization_id = ?", self.id)
  end

  def remove(user : User)
    OrganizationUser.find!({user.id, self.id}).destroy
  end

  def add(user : User, permission : App::Permissions = App::Permissions::User)
    OrganizationUser.new(
      user_id: user.id,
      organization_id: self.id,
      permission: permission
    ).save!
  end

  def invite(user : User, permission : App::Permissions = App::Permissions::User, expires : Time? = nil)
    OrganizationInvite.new(
      email: user.email,
      organization_id: self.id,
      permission: permission,
      expires: expires
    ).save!
  end

  def invite(email : String, permission : App::Permissions = App::Permissions::User, expires : Time? = nil)
    OrganizationInvite.new(
      email: email,
      organization_id: self.id,
      permission: permission,
      expires: expires
    ).save!
  end

  def create_admin_group!
    return admin_group if admin_group_id

    group = Group.new(
      name: "Administrators",
      description: "Organization administrators with full access",
      permission: App::Permissions::Admin,
      organization_id: self.id
    )
    group.save!

    self.admin_group_id = group.id
    save!

    # Add owner to admin group if exists
    if owner_id && (owner_user = owner)
      group.add_user(owner_user, is_admin: true)
    end

    group
  end

  def ensure_admin_group!
    return admin_group if admin_group_id && admin_group
    create_admin_group!
  end

  def user_has_permission?(user : User, required_permission : App::Permissions) : Bool
    # Check direct organization membership first (for backward compatibility)
    org_user = OrganizationUser.find?({user.id, self.id})
    if org_user && org_user.permission.value <= required_permission.value
      return true
    end

    # Check group-based permissions
    user_groups = Group.join(:inner, GroupUser, :group_id)
      .where("groups.organization_id = ? AND group_users.user_id = ?", self.id, user.id)

    user_groups.any? { |group| group.permission.value <= required_permission.value }
  end

  def user_is_admin?(user : User) : Bool
    return false unless admin_group_id
    admin_group.not_nil!.user_is_member?(user)
  end

  def user_can_manage_groups?(user : User) : Bool
    user_is_admin?(user)
  end
end
